name: Install WDK
description: "Install Windows Driver Kit via NuGet or WinGet with robust error handling and verification"

inputs:
  version:
    description: "WDK version to install. Format: 10.0.XXXXX or 10.0.XXXXX.YYYY. If QFE (4th component) is omitted, the latest available QFE is selected."
    required: true
  source:
    description: "Source to install WDK from (nuget or winget)."
    required: true
    default: "nuget"
  # required to set WDKBinRoot and WDKToolRoot based on the host architecture when using nuget
  host:
    description: "Host architecture (amd64 or arm64). Required when source is nuget."
    required: true
  # required to set WDKContentRoot based on the target architecture when using nuget
  target:
    description: "Target architecture (amd64 or arm64). Required when source is nuget."
    required: false

runs:
  using: "composite"
  steps:
    - name: Validate inputs
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $source = '${{ inputs.source }}'
        $version = '${{ inputs.version }}'
        $hostArch = '${{ inputs.host }}'
        $targetArch = '${{ inputs.target }}'

        Write-Host "Validating WDK installation inputs..."
        Write-Host "Source: $source"
        Write-Host "Version: $version"
        Write-Host "Host: $hostArch"
        Write-Host "Target: $targetArch"

        # Validate source
        if ($source -notin @('nuget', 'winget')) {
            throw "Invalid source: $source. Must be 'nuget' or 'winget'."
        }

        # Validate version format
        if ($version -notmatch '^10\.0\.\d{5}(\.\d{1,4})?$') {
            throw "Invalid version format: $version. Expected format: 10.0.XXXXX or 10.0.XXXXX.YYYY"
        }

        # Validate architecture inputs for NuGet
        if ($source -eq 'nuget') {
            if ([string]::IsNullOrWhiteSpace($hostArch) -or $hostArch -notin @('amd64', 'arm64')) {
                throw "Invalid or missing host architecture: '$hostArch'. Must be 'amd64' or 'arm64' when source is nuget."
            }
            # Set target architecture to host architecture if not specified
            if ([string]::IsNullOrWhiteSpace($targetArch)) {
                $targetArch = $hostArch
            }
        }

        # Validate that host and target are not provided when using WinGet
        if ($source -eq 'winget') {
            if (-not [string]::IsNullOrWhiteSpace($hostArch)) {
                Write-Host "Ignoring host architecture input. WDK installed via WinGet includes all architectures."
            }
            if (-not [string]::IsNullOrWhiteSpace($targetArch)) {
                Write-Host "Ignoring target architecture input. WDK installed via WinGet includes all architectures."
            }
        }

        Write-Host "✅ Input validation passed"

    - name: Install WDK via NuGet
      if: inputs.source == 'nuget'
      shell: pwsh
      run: |
        # Optimization: Set strict mode and error handling
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'
        $ProgressPreference = 'SilentlyContinue'

        # Helper function to select a single package from a collection
        function Select-SinglePackage {
            param(
                [Parameter(Mandatory)]
                [object[]]$Packages,
                [Parameter(Mandatory)]
                [string]$PackageType
            )
            
            if ($Packages.Count -eq 1) {
                return $Packages[0]
            } elseif ($Packages.Count -gt 1) {
                throw "Multiple $PackageType packages found: $($Packages.Name -join ', '). Expected exactly one."
            } else {
                throw "No $PackageType package found."
            }
        }

        # Input validation and normalization
        $hostArch = switch ('${{ inputs.host }}') {
            'amd64' { 'x64' }
            'arm64' { 'ARM64' }
        }
        $targetArch = switch ('${{ inputs.target }}') {
            'amd64' { 'x64' }
            'arm64' { 'ARM64' }
        }
        $inputVersion = '${{ inputs.version }}'
        $versionParts = $inputVersion.Split('.')
        $sdkVersion = $versionParts[0..2] -join '.'
        $version = $inputVersion

        if ($versionParts.Length -eq 3) {
            # No QFE specified, find the latest QFE for this base version
            Write-Host "No QFE specified, searching for latest QFE for version $inputVersion..."
            try {
                Write-Host "Trying NuGet API..."
                $nugetApiUrl = "https://api.nuget.org/v3-flatcontainer/microsoft.windows.wdk.x64/index.json"
                $response = Invoke-RestMethod -Uri $nugetApiUrl -TimeoutSec 30
                $availableVersions = @($response.versions | Where-Object { $_ -match '^\d+\.\d+\.\d+\.\d+$' })
                Write-Host "Found $(@($availableVersions).Count) versions using NuGet API"

                # Filter versions that match the base version and find the latest QFE
                $matchingVersions = @($availableVersions | Where-Object { $_.StartsWith("$inputVersion.") })
                if (@($matchingVersions).Count -eq 0) {
                    Write-Warning "No QFE versions found for base version $inputVersion, using base version..."
                } else {
                    $version = $matchingVersions | Sort-Object { [System.Version]$_ } | Select-Object -Last 1
                    Write-Host "Found latest QFE version: $version"
                }
            } catch {
                Write-Warning "Failed to query NuGet for latest QFE version: $_"
                Write-Host "Using input version $inputVersion without QFE lookup"
            }
        } else {
            Write-Host "Using specified version: $version"
        }

        $packages = "C:\packages"

        # Download all architectures supported by `windows-drivers-rs` and CPP SDK package
        $architectures = @('x64', 'ARM64') 
        $packagesToInstall = @()
        foreach ($architecture in $architectures) {
            $packageName = "Microsoft.Windows.WDK.$architecture"
            if (-not ($packagesToInstall | Where-Object { $_.PackageId -eq $packageName })) {
                $packagesToInstall += [PSCustomObject]@{
                    PackageId   = $packageName
                    Version     = $version
                    DisplayName = "$packageName.$version"
                }
            }
        }

        $sdkPackageDisplayName = "Microsoft.Windows.SDK.CPP.$version"
        if (-not ($packagesToInstall | Where-Object { $_.PackageId -eq 'Microsoft.Windows.SDK.CPP' })) {
            $packagesToInstall += [PSCustomObject]@{
                PackageId   = 'Microsoft.Windows.SDK.CPP'
                Version     = $version
                DisplayName = $sdkPackageDisplayName
            }
        }

        foreach ($package in $packagesToInstall) {
            Write-Host "Installing $($package.DisplayName) (package id: $($package.PackageId)) version $($package.Version)..."
            nuget install $package.PackageId -Version $package.Version -OutputDirectory $packages -DependencyVersion Ignore
            if ($LASTEXITCODE -ne 0) {
                throw "Failed to install $($package.DisplayName) version $($package.Version)"
            }
        }

        Write-Host "✅ Successfully downloaded all packages for version `$version` to `$packages`"

        # Discover installed package paths in packages folder
        Write-Host "Discovering installed package paths..."

        $packageDirs = Get-ChildItem -Path $packages -Directory | Where-Object { $_.Name -like "Microsoft.Windows.*.$version" }

        $sdkPackageDirs = @($packageDirs | Where-Object { $_.Name -like "Microsoft.Windows.SDK.CPP.$version" })
        if ($sdkPackageDirs.Count -eq 0) {
            throw "No CPP SDK packages found in `$packages` folder"
        }

        $sdkPackageDir = (Select-SinglePackage -Packages $sdkPackageDirs -PackageType "Windows CPP SDK $version").FullName
        Write-Host "Found CPP SDK at $sdkPackageDir"

        $wdkPackageDirs = @($packageDirs | Where-Object { $_.Name -like "Microsoft.Windows.WDK.*.$version" })
        Write-Host "Found $($wdkPackageDirs.Count) WDK package(s):"
        if ($wdkPackageDirs.Count -eq 0) {
            throw "No WDK packages found in `$packages` folder"
        }
        foreach ($dir in $wdkPackageDirs) {
            Write-Host "  - $($dir.Name)"
        }
        # Find host architecture WDK package
        $hostWdkPackage = (Select-SinglePackage -Packages ($wdkPackageDirs | Where-Object { $_.Name -eq "Microsoft.Windows.WDK.$hostArch.$version" }) -PackageType "WDK for host $hostArch").FullName
        Write-Host "Using WDK host architecture ($hostArch) package: $hostWdkPackage"
        # Find target architecture WDK package
        $targetWdkPackage = (Select-SinglePackage -Packages ($wdkPackageDirs | Where-Object { $_.Name -eq "Microsoft.Windows.WDK.$targetArch.$version" }) -PackageType "WDK for target $targetArch").FullName
        Write-Host "Using WDK target architecture ($targetArch) package: $targetWdkPackage"

        $envVars = @{
            "Version_Number" = "$sdkVersion.0"
            "WindowsSdkBinPath" = "$sdkPackageDir\c\bin"
            "WDKContentRoot" = "$targetWdkPackage\c\"
            "WDKBinRoot" = "$hostWdkPackage\c\bin"
            "WDKToolRoot" = "$hostWdkPackage\c\tools"
            "FullVersionNumber" = "$version"
            "NugetPackagesRoot" = "$packages"
        }

        # Validate paths exist before setting environment variables
        $paths = @("WindowsSdkBinPath", "WDKContentRoot", "WDKBinRoot", "WDKToolRoot")
        foreach ($pathKey in $paths) {
            $path = $envVars[$pathKey]
            if (-not (Test-Path $path)) {
                throw "Critical path not found: $pathKey = $path"
            }
        }

        $envVars.GetEnumerator() | ForEach-Object {
            Write-Host "Setting $($_.Key) environment variable: $($_.Value)"
            $line = '{0}={1}' -f $_.Key, $_.Value
            Add-Content -Path $env:GITHUB_ENV -Value $line
        }

    - name: Remove existing Windows SDK packages
      if: inputs.source == 'winget'
      uses: ./.github/actions/uninstall-winget-package
      with:
        queries: |
          Microsoft.WindowsSDK
          Windows Software Development Kit

    - name: Remove existing Windows Driver Kit packages
      if: inputs.source == 'winget'
      uses: ./.github/actions/uninstall-winget-package
      with:
        queries: |
          Microsoft.WindowsWDK
          Windows Driver Kit

    - name: Calculate SDK version
      if: inputs.source == 'winget'
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $inputVersion = '${{ inputs.version }}'
        Write-Host "Processing WDK version: $inputVersion"

        $versionParts = $inputVersion.Split('.')
        $sdkVersion = $versionParts[0..2] -join '.'
        Write-Host "Calculated SDK version: $sdkVersion from input version: $inputVersion"
        Write-Output "SDK_VERSION=$sdkVersion" >> $env:GITHUB_ENV
        Write-Output "Version_Number=$sdkVersion.0" >> $env:GITHUB_ENV

    - name: Install Windows SDK
      if: inputs.source == 'winget'
      uses: ./.github/actions/install-winget-package
      with:
        package-id: Microsoft.WindowsSDK.${{ env.SDK_VERSION }}
        # Workaround for 10.0.22621 SDK installer bug:
        # The installer concatenates long strings to the log path provided by winget, creating paths exceeding 256 chars
        # when winget appends `/log`. Specifying override args explicitly prevents winget from appending `/log`.
        override-args: ${{ (inputs.version == '10.0.22621' || startsWith(inputs.version, '10.0.22621.')) && '/q' || '' }}
        skip-if-installed: "true"
        timeout-minutes: "10"

    - name: Install Windows Driver Kit
      if: inputs.source == 'winget'
      uses: ./.github/actions/install-winget-package
      with:
        package-id: Microsoft.WindowsWDK.${{ inputs.version }}
        skip-if-installed: "true"
        timeout-minutes: "10"