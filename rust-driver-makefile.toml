# This file can be leveraged to build downstream drivers. See examples at https://github.com/microsoft/Windows-rust-drivers-samples

# FIXME: this flow is based on the signing process of a KMDF PNP driver. There should be different flows availabe for different types of drivers as outlined in https://learn.microsoft.com/en-us/windows-hardware/drivers/install/test-signing-driver-packages 
[config]
min_version = "0.37.3"
init_task = "wdk-build-init"

[env]
# This allows all workspace members to access this makefile
CARGO_MAKE_EXTEND_WORKSPACE_MAKEFILE = true

# CARGO_MAKE_CARGO_BUILD_TEST_FLAGS is set to "--all-features" by default in cargo-make: https://github.com/sagiegurari/cargo-make/blob/c0abc4d0ae1bcc03adde22b63fa0accc4af2b3bc/src/lib/descriptor/makefiles/stable.toml#L31
# This is set to "" here to match the default behavior of Cargo. 
CARGO_MAKE_CARGO_BUILD_TEST_FLAGS = { unset = true }

[plugins.impl.rust-env-update]
script = '''
assert ${task.has_script} "script is required for rust-env-update plugin"
assert_eq ${task.script_runner} @rust "script_runner must be set to @rust for rust-env-update plugin"

cargo_make_rust_script_provider = get_env CARGO_MAKE_RUST_SCRIPT_PROVIDER
assert_eq ${cargo_make_rust_script_provider} rust-script "rust-env-update plugin is only compatible with rust-script"

taskjson = json_parse ${task.as_json}

# Install dependency crate
out = exec --fail-on-error cargo install ${taskjson.install_crate.crate_name} --version ${taskjson.install_crate.min_version}
assert_eq ${out.code} 0 "[tasks.${task.name}]'s install_crate failed with exit code: ${out.code}\nstdout:\n${out.stdout}\nstderr:\n${out.stderr}"

# Execute rust-script
taskjson = json_parse ${task.as_json}
filepath = set "${CARGO_MAKE_CRATE_CUSTOM_TRIPLE_TARGET_DIRECTORY}/cargo-make-script/${task.name}/main.rs"
# If a file already exists, only overwrite it if the script has changed (so that rust-script caching can be leveraged)
if is_file ${filepath}
    old_hash = digest --algo sha256 --file ${filepath}
    new_hash = digest --algo sha256 ${taskjson.script}
    if not eq ${old_hash} ${new_hash}
        writefile ${filepath} ${taskjson.script}
    end
else
    writefile ${filepath} ${taskjson.script}
end
cli_args = array_join ${flow.cli.args} " "
# rust-script will try to consume --help, so help must be passed via TRIGGER_HELP env var in order to provide clap help output
trigger_help = get_env TRIGGER_HELP
if not is_empty ${trigger_help}
    cli_args = concat ${cli_args} " --help"
end
out = exec --fail-on-error rust-script --base-path ${taskjson.env.CARGO_MAKE_CURRENT_TASK_INITIAL_MAKEFILE_DIRECTORY} ${CARGO_MAKE_CRATE_CUSTOM_TRIPLE_TARGET_DIRECTORY}/cargo-make-script/${task.name}/main.rs %{cli_args}
assert_eq ${out.code} 0 "[tasks.${task.name}]'s script failed with exit code: ${out.code}\nstdout:\n${out.stdout}\nstderr:\n${out.stderr}\nThe temporary rust-script file is located at ${CARGO_MAKE_CRATE_CUSTOM_TRIPLE_TARGET_DIRECTORY}/cargo-make-script/${task.name}/main.rs"

# Set cargo-make env vars based on output of rust-script
script_output = trim ${out.stdout}
if not is_empty ${script_output}
    script_output_array = split ${script_output} \n
    stdout_first_line = array_get ${script_output_array} 0
    assert_eq ${stdout_first_line} "FORWARDING ARGS TO CARGO-MAKE:" "[tasks.${task.name}]'s script output did not begin with \"FORWARDING ARGS TO CARGO-MAKE:\". Was `--help` passed as one of the arguments?\nstdout:\n${out.stdout}\nstderr:\n${out.stderr}\nThe temporary rust-script file is located at ${CARGO_MAKE_CRATE_CUSTOM_TRIPLE_TARGET_DIRECTORY}/cargo-make-script/${task.name}/main.rs"
    array_remove ${script_output_array} 0
    for line in ${script_output_array}
        parts = split ${line} =
        key = array_get ${parts} 0
        value = array_get ${parts} 1
        set_env ${key} ${value}
    end
end
'''

[tasks.wdk-build-init]
private = true
install_crate = { crate_name = "rust-script", min_version = "0.30.0" }
plugin = "rust-env-update"
script_runner = "@rust"
script = '''
//! ```cargo
//! [dependencies]
//! wdk-build = { path = "./crates/wdk-build", version = "0.1.0" }
//! ```
#![allow(unused_doc_comments)]

wdk_build::cargo_make::validate_and_forward_args();
wdk_build::cargo_make::setup_path()?;
'''

[tasks.help]
workspace = false
env = { "TRIGGER_HELP" = "1" }
run_task = "wdk-build-init"

[tasks.copy-inx-to-output]
script_runner = "@rust"
script = '''
use std::path::PathBuf;

let crate_name = std::env::var("CARGO_MAKE_CRATE_FS_NAME").expect("CARGO_MAKE_CRATE_FS_NAME should be set by cargo-make");
let cargo_make_working_directory = std::env::var("CARGO_MAKE_WORKING_DIRECTORY").expect("CARGO_MAKE_WORKING_DIRECTORY should be set by cargo-make via the env section of rust-driver-makefile.toml");
let output_directory = std::env::var("WDK_BUILD_OUTPUT_DIRECTORY").expect("WDK_BUILD_OUTPUT_DIRECTORY should be set by cargo-make via the env section of rust-driver-makefile.toml");

let output_folder_path = PathBuf::from(&output_directory);
if !output_folder_path.exists() {
    std::fs::create_dir_all(&output_folder_path).expect(&format!("creation of '{}' folder should succeed", output_folder_path.display()));
}

let source_file = format!("{cargo_make_working_directory}/{crate_name}.inx");
let destination_file = format!("{output_directory}/{crate_name}.inf");
std::fs::copy(&source_file, &destination_file).expect(&format!("copy of '{source_file}' file to '{destination_file}' file should succeed"));
'''

[tasks.generate-sys-file]
dependencies = ["build"]
script_runner = "@rust"
script = '''
let crate_name = std::env::var("CARGO_MAKE_CRATE_FS_NAME").expect("CARGO_MAKE_CRATE_FS_NAME should be set by cargo-make");
let output_directory = std::env::var("WDK_BUILD_OUTPUT_DIRECTORY").expect("WDK_BUILD_OUTPUT_DIRECTORY should be set by cargo-make via the env section of rust-driver-makefile.toml");

let source_file = format!("{output_directory}/{crate_name}.dll");
let destination_file = format!("{output_directory}/{crate_name}.sys");
std::fs::copy(&source_file, &destination_file).expect(&format!("copy of '{source_file}' file to '{destination_file}' file should succeed"));
'''

[tasks.stampinf]
dependencies = ["copy-inx-to-output"]
command = "stampinf"
args = [
  "-f",
  "${WDK_BUILD_OUTPUT_DIRECTORY}/${CARGO_MAKE_CRATE_FS_NAME}.inf",
  "-d",
  "*",
  "-a",
  "amd64",
  "-c",
  "${CARGO_MAKE_CRATE_FS_NAME}.cat",
  "-v",
  "*",
  "-k",
  "1.33",
]

[tasks.infverif]
dependencies = ["stampinf"]
command = "infverif"
args = [
  "/v",
  "/w",
  "@@split(WDK_BUILD_ADDITIONAL_INFVERIF_FLAGS, )",
  "${WDK_BUILD_OUTPUT_DIRECTORY}/${CARGO_MAKE_CRATE_FS_NAME}.inf",
]

[tasks.copy-sys-to-package]
dependencies = ["generate-sys-file"]
script_runner = "@rust"
script = '''
use std::path::PathBuf;

let crate_name = std::env::var("CARGO_MAKE_CRATE_FS_NAME").expect("CARGO_MAKE_CRATE_FS_NAME should be set by cargo-make");
let output_directory = std::env::var("WDK_BUILD_OUTPUT_DIRECTORY").expect("WDK_BUILD_OUTPUT_DIRECTORY should be set by cargo-make via the env section of rust-driver-makefile.toml");

let package_folder_path = [output_directory.as_str(), "package"].iter().collect::<PathBuf>();
if !package_folder_path.exists() {
    std::fs::create_dir(&package_folder_path).expect(&format!("creation of '{}' folder should succeed", package_folder_path.display()));
}

let source_file = format!("{output_directory}/{crate_name}.sys");
let destination_file = format!("{output_directory}/package/{crate_name}.sys");
std::fs::copy(&source_file, &destination_file).expect(&format!("copy of '{source_file}' file to '{destination_file}' file should succeed"));
'''

[tasks.copy-pdb-to-package]
dependencies = ["build"]
script_runner = "@rust"
script = '''
use std::path::PathBuf;

let crate_name = std::env::var("CARGO_MAKE_CRATE_FS_NAME").expect("CARGO_MAKE_CRATE_FS_NAME should be set by cargo-make");
let output_directory = std::env::var("WDK_BUILD_OUTPUT_DIRECTORY").expect("WDK_BUILD_OUTPUT_DIRECTORY should be set by cargo-make via the env section of rust-driver-makefile.toml");

let package_folder_path = [output_directory.as_str(), "package"].iter().collect::<PathBuf>();
if !package_folder_path.exists() {
    std::fs::create_dir(&package_folder_path).expect(&format!("creation of '{}' folder should succeed", package_folder_path.display()));
}

let source_file = format!("{output_directory}/{crate_name}.pdb");
let destination_file = format!("{output_directory}/package/{crate_name}.pdb");
std::fs::copy(&source_file, &destination_file).expect(&format!("copy of '{source_file}' file to '{destination_file}' file should succeed"));
'''

[tasks.copy-inf-to-package]
dependencies = ["stampinf"]
script_runner = "@rust"
script = '''
use std::path::PathBuf;

let crate_name = std::env::var("CARGO_MAKE_CRATE_FS_NAME").expect("CARGO_MAKE_CRATE_FS_NAME should be set by cargo-make");
let output_directory = std::env::var("WDK_BUILD_OUTPUT_DIRECTORY").expect("WDK_BUILD_OUTPUT_DIRECTORY should be set by cargo-make via the env section of rust-driver-makefile.toml");

let package_folder_path = [output_directory.as_str(), "package"].iter().collect::<PathBuf>();
if !package_folder_path.exists() {
    std::fs::create_dir(&package_folder_path).expect(&format!("creation of '{}' folder should succeed", package_folder_path.display()));
}

let source_file = format!("{output_directory}/{crate_name}.inf");
let destination_file = format!("{output_directory}/package/{crate_name}.inf");
std::fs::copy(&source_file, &destination_file).expect(&format!("copy of '{source_file}' file to '{destination_file}' file should succeed"));
'''

[tasks.copy-map-to-package]
dependencies = ["build"]
script_runner = "@rust"
script = '''
use std::path::PathBuf;

let crate_name = std::env::var("CARGO_MAKE_CRATE_FS_NAME").expect("CARGO_MAKE_CRATE_FS_NAME should be set by cargo-make");
let output_directory = std::env::var("WDK_BUILD_OUTPUT_DIRECTORY").expect("WDK_BUILD_OUTPUT_DIRECTORY should be set by cargo-make via the env section of rust-driver-makefile.toml");

let package_folder_path = [output_directory.as_str(), "package"].iter().collect::<PathBuf>();
if !package_folder_path.exists() {
    std::fs::create_dir(&package_folder_path).expect(&format!("creation of '{}' folder should succeed", package_folder_path.display()));
}

let source_file = format!("{output_directory}/deps/{crate_name}.map");
let destination_file = format!("{output_directory}/package/{crate_name}.map");
std::fs::copy(&source_file, &destination_file).expect(&format!("copy of '{source_file}' file to '{destination_file}' file should succeed"));
'''

[tasks.inf2cat]
dependencies = ["copy-sys-to-package", "copy-inf-to-package"]
command = "inf2cat"
args = [
  "/driver:${WDK_BUILD_OUTPUT_DIRECTORY}/package",
  "/os:10_NI_X64,10_VB_X64",                       # TODO: this should be a parameter
  "/uselocaltime",
]

[tasks.generate-certificate-if-needed]
# This script can't be in a `condition_script` block because of https://github.com/sagiegurari/cargo-make/issues/987
script_runner = "@duckscript"
script = '''
out = exec certmgr.exe -put -s WDRTestCertStore -c -n WDRLocalTestCert ${WDK_BUILD_OUTPUT_DIRECTORY}/WDRLocalTestCert.cer
if not eq ${out.code} 0
    echo WDRLocalTestCert not found in WDRTestCertStore. Generating new certificate.
    cm_run_task generate-certificate
end
'''

[tasks.generate-certificate]
private = true
command = "makecert"
args = [
  "-r",
  "-pe",
  "-a",
  "SHA256",
  "-eku",
  "1.3.6.1.5.5.7.3.3",
  "-ss",
  "WDRTestCertStore",                                   # TODO: this should be a parameter
  "-n",
  "CN=WDRLocalTestCert",                                # TODO: this should be a parameter
  "${WDK_BUILD_OUTPUT_DIRECTORY}/WDRLocalTestCert.cer",
]

[tasks.copy-certificate-to-package]
dependencies = ["generate-certificate-if-needed"]
script_runner = "@rust"
script = '''
use std::path::PathBuf;

let output_directory = std::env::var("WDK_BUILD_OUTPUT_DIRECTORY").expect("WDK_BUILD_OUTPUT_DIRECTORY should be set by cargo-make via the env section of rust-driver-makefile.toml");

let package_folder_path = [output_directory.as_str(), "package"].iter().collect::<PathBuf>();
if !package_folder_path.exists() {
    std::fs::create_dir(&package_folder_path).expect(&format!("creation of '{}' folder should succeed", package_folder_path.display()));
}

let source_file = format!("{output_directory}/WDRLocalTestCert.cer");
let destination_file = format!("{output_directory}/package/WDRLocalTestCert.cer");
std::fs::copy(&source_file, &destination_file).expect(&format!("copy of '{source_file}' file to '{destination_file}' file should succeed"));
'''

[tasks.signtool]
dependencies = ["inf2cat", "generate-certificate-if-needed"]
command = "signtool"
args = [
  "sign",
  "/v",
  "/s",
  "WDRTestCertStore",                                                      # TODO: this should be a parameter
  "/n",
  "WDRLocalTestCert",                                                      # TODO: this should be a parameter
  "/t",
  "http://timestamp.digicert.com",
  "/fd",
  "SHA256",
  "${WDK_BUILD_OUTPUT_DIRECTORY}/package/${CARGO_MAKE_CRATE_FS_NAME}.cat",
]

[tasks.package-driver]
dependencies = [
  "copy-sys-to-package",
  "copy-pdb-to-package",
  "copy-inf-to-package",
  "copy-map-to-package",
  "copy-certificate-to-package",
  "signtool",
  "infverif",
]

[tasks.default]
alias = "package-driver"

# TODO: mark drivers
